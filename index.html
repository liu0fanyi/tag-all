<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Tauri + Leptos App</title>
  <link data-trunk rel="css" href="styles.css" />
  <link data-trunk rel="copy-dir" href="public" />
  <link data-trunk rel="rust" data-wasm-opt="z" />

  <!-- Katex for Math Support -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <script>
    // Add styles for editor overlay and highlighting
    const style = document.createElement('style');
    style.textContent = `
      .editor-container {
        position: relative;
        width: 100%;
        height: 100%;
        min-height: 200px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
      }
      
      .editor-container {
        position: relative;
        width: 100%;
        height: 100%;
        min-height: 200px;
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
      }
      
      /* Shared Typography & Metrics - MUST BE IDENTICAL */
      .memo-textarea, .highlight-layer, .highlight-layer code {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        font-size: 14px;
        line-height: 1.5;
        font-variant-ligatures: none !important;
        font-weight: normal !important;
        font-style: normal !important;
        tab-size: 4;
      }

      /* Layout Containers */
      .memo-textarea, .highlight-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 10px;
        border: none;
        box-sizing: border-box;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .memo-textarea {
        z-index: 2;
        overflow: auto; /* User scrolls this */
        background: transparent;
        color: transparent;
        caret-color: #d4d4d4;
        resize: none;
        outline: none;
      }

      .highlight-layer {
        z-index: 1;
        overflow: hidden; /* Hide scrollbars, synced via JS */
        pointer-events: none;
        background-color: #1e1e1e;
        color: #d4d4d4;
      }

      /* Inner Code Element - Must flow naturally */
      .highlight-layer code {
        position: static; /* Force static to allow parent to scroll */
        display: inline; /* Or block, but inline works in pre-wrap */
        overflow: visible;
        background: transparent;
        padding: 0; margin: 0;
        border: none;
        /* Inherit font styles from shared block */
      }
      
      .memo-textarea {
        z-index: 2;
        color: transparent;
        caret-color: #d4d4d4; /* Default caret color */
        resize: none;
        outline: none;
      }
      
      /* Make selection visible on transparent text */
      .memo-textarea::selection {
        background: rgba(38, 79, 120, 0.5); /* VSCode selection style */
        color: transparent;
      }
      
      .highlight-layer {
        z-index: 1;
        pointer-events: none;
        color: #d4d4d4; /* Default text color */
        background-color: #1e1e1e; /* VSCode background */
      }
      
      /* Syntax Highlighting Colors (VSCode Dark+ inspired) */
      /* Note: Removed font-weight: bold and font-style: italic to prevent layout shift */
      .hl-header { color: #569cd6; } 
      .hl-code-block { background-color: #2d2d2d; }
      .hl-code-inline { color: #ce9178; }
      .hl-bold { color: #dcdcaa; } /* Was bold */
      .hl-italic { } /* Was italic, now just normal to keep alignment */
      .hl-link { color: #9cdcfe; text-decoration: underline; }
      .hl-image { color: #ce9178; }
      .hl-math { color: #b5cea8; }
      .hl-list { color: #6796e6; }
      .hl-quote { color: #6a9955; } /* Was italic */
      .hl-hr { color: #808080; border-bottom: 1px solid #808080; }
      .hl-ref { color: #569cd6; } /* Reference definition */
    `;
    document.head.appendChild(style);
  </script>

  <script>
    /**
     * Lightweight Vim/Helix Modal Editor
     * Supports: hjkl, w/b/e, dd/yy/p, i/a/o/O, Esc
     */
    window.VimMode = (function () {
      const state = {
        mode: 'insert', // 'normal' or 'insert'
        register: '',   // yanked text
        pending: '',    // pending command (e.g., 'd' waiting for 'd')
      };

      // Block cursor element
      let cursorEl = null;

      function createCursor() {
        if (!cursorEl) {
          cursorEl = document.createElement('div');
          cursorEl.className = 'vim-block-cursor';
          document.body.appendChild(cursorEl);
        }
      }

      function updateBlockCursor(textarea) {
        if (state.mode === 'normal' && document.activeElement === textarea) {
          createCursor();
          // Use selection end/start based on direction to track the "active" cursor end
          const pos = (textarea.selectionDirection === 'backward')
            ? textarea.selectionStart
            : textarea.selectionEnd;
          const coords = getCursorXY(textarea, pos);
          const rect = textarea.getBoundingClientRect();
          const scrollTop = textarea.scrollTop;

          // Calculate absolute position
          // coords are relative to padding-box origin (-scrollTop to get visual position)
          const visibleTop = coords.top - scrollTop;
          const visibleLeft = coords.left - textarea.scrollLeft;

          // Get exact border widths to offset the cursor correctly
          const computedStyle = getComputedStyle(textarea);
          const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
          const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;

          // Only show if inside visible content area (approx)
          if (visibleTop >= -coords.height && visibleTop <= textarea.clientHeight &&
            visibleLeft >= 0 && visibleLeft <= textarea.clientWidth) {

            cursorEl.style.display = 'block';
            // rect.top is border-box top. content starts at rect.top + borderTop
            cursorEl.style.top = (rect.top + borderTop + visibleTop + window.scrollY) + 'px';
            cursorEl.style.left = (rect.left + borderLeft + visibleLeft + window.scrollX) + 'px';
            cursorEl.style.height = coords.height + 'px';

            // Measure character width at cursor? 
            // We can assume monospaced, but better to measure.
            // Actually getCursorXY logic just gave point.
            // Let's set a default min-width but try to match content.
            // For now fixed width is safer/easier, or just a square.
            // Let's grab the char at cursor to measure width?
            // Simple: just use "ch" unit if font is mono, or measure 'M'
            cursorEl.style.width = '1ch';

            // Get character under cursor to display in inverted color?
            // That's complex (requires overlaying text).
            // Classic web VIM usually just uses semi-transparent block.
            // cursorEl.textContent = textarea.value[pos] || ' ';
            cursorEl.textContent = ''; // Clear text content to avoid ghosting artifacts
          } else {
            cursorEl.style.display = 'none';
          }
        } else {
          if (cursorEl) cursorEl.style.display = 'none';
        }
      }

      // Word boundaries for w/b/e
      // Only treat Alphanumeric (Latins, numbers, _) and Hanzi (Chinese chars) as distinct "word characters".
      // Punctuation (both ASCII and CJK full-width) will be treated as "non-word characters", acting as delimiters or separate words.
      const isWordChar = c => /[\w\u4e00-\u9fa5]/.test(c);
      const isWhitespace = c => /\s/.test(c);

      function getLineInfo(textarea) {
        const text = textarea.value;
        const pos = textarea.selectionStart;
        const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
        const lineEnd = text.indexOf('\n', pos);
        return {
          lineStart,
          lineEnd: lineEnd === -1 ? text.length : lineEnd,
          lineText: text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd)
        };
      }

      // Helper to calculate cursor coordinates
      // Helper to find text node and offset for a given index in a root element
      function getTextNodeAt(root, targetIndex) {
        let currentIndex = 0;
        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null, false);
        let node;
        while (node = walker.nextNode()) {
          const len = node.textContent.length;
          if (currentIndex + len >= targetIndex) {
            return { node, offset: targetIndex - currentIndex };
          }
          currentIndex += len;
        }
        return null;
      }

      // Helper to calculate cursor coordinates
      // Now attempts to use Highlight Layer Range first for perfect alignment
      function getCursorXY(textarea, selectionPoint) {
        // 1. Try Highlight Layer measurement (if available)
        const container = textarea.closest('.editor-container');
        if (container) {
          const highlightLayer = container.querySelector('.highlight-layer code');
          if (highlightLayer) {
            const hit = getTextNodeAt(highlightLayer, selectionPoint);
            if (hit) {
              try {
                const range = document.createRange();
                range.setStart(hit.node, hit.offset);
                range.collapse(true);
                const rects = range.getClientRects();
                if (rects.length > 0) {
                  const rect = rects[0];
                  const containerRect = highlightLayer.parentElement.getBoundingClientRect();
                  // Calculate relative coordinates
                  return {
                    top: rect.top - containerRect.top + highlightLayer.parentElement.scrollTop,
                    left: rect.left - containerRect.left + highlightLayer.parentElement.scrollLeft,
                    height: rect.height || 20
                  };
                }
              } catch (e) { /* Ignore range errors */ }
            }
          }
        }

        // 2. Fallback: Mirror Div (cleaned up)
        const div = document.createElement('div');
        div.className = textarea.className;

        // Reset absolute positioning & visibility
        div.style.position = 'absolute';
        div.style.top = '0px';
        div.style.left = '0px';
        div.style.visibility = 'hidden';
        div.style.height = 'auto';
        div.style.overflow = 'hidden';

        // Match sizing
        div.style.boxSizing = 'border-box';
        div.style.width = textarea.clientWidth + 'px';
        div.style.padding = window.getComputedStyle(textarea).padding;
        div.style.border = 'none';
        div.style.margin = '0';

        // Zoom handling
        const style = window.getComputedStyle(textarea);
        if (style.zoom && style.zoom !== '1') div.style.zoom = style.zoom;

        div.textContent = textarea.value.substring(0, selectionPoint);
        const span = document.createElement('span');
        span.textContent = '|';
        div.appendChild(span);

        textarea.parentElement.appendChild(div);

        const spanRect = span.getBoundingClientRect();
        const divRect = div.getBoundingClientRect();

        const coordinates = {
          top: spanRect.top - divRect.top,
          left: spanRect.left - divRect.left,
          height: parseInt(style['line-height']) || 20
        };

        textarea.parentElement.removeChild(div);
        return coordinates;
      }

      function scrollToCursor(textarea, pos) {
        // coords relative to padding-box origin
        const coords = getCursorXY(textarea, pos);
        const { scrollTop, clientHeight } = textarea;

        // Visible cursor Y = coords.top - scrollTop
        if (coords.top < scrollTop) {
          textarea.scrollTop = coords.top;
        } else if (coords.top + coords.height > scrollTop + clientHeight) {
          textarea.scrollTop = coords.top + coords.height - clientHeight + coords.height;
        }
      }

      function moveCursor(textarea, newPos) {
        const pos = Math.max(0, Math.min(newPos, textarea.value.length));
        textarea.setSelectionRange(pos, pos);
        scrollToCursor(textarea, pos);
        updateBlockCursor(textarea);
      }

      function findNextWord(text, pos) {
        if (pos >= text.length) return pos;

        let i = pos;
        let startType = isWordChar(text[i]);

        // 1. Skip current word or sequence of same-type non-word chars
        while (i < text.length) {
          let currentType = isWordChar(text[i]);
          let isSpace = isWhitespace(text[i]);

          // If we hit whitespace, stop skipping word
          if (isSpace) break;
          // If type changes (word <-> punctuation), stop
          if (currentType !== startType) break;
          i++;
        }

        // 2. Skip whitespace to find start of next
        while (i < text.length && isWhitespace(text[i])) {
          i++;
        }

        return i;
      }

      function findPrevWord(text, pos) {
        if (pos <= 0) return 0;
        let i = pos - 1;

        // 1. Skip whitespace backwards
        while (i > 0 && isWhitespace(text[i])) {
          i--;
        }

        // 2. Determine type of distinct word end
        let endType = isWordChar(text[i]);

        // 3. Go back to start of this word/punctuation block
        while (i > 0) {
          let prevChar = text[i - 1];
          if (isWhitespace(prevChar)) break;
          if (isWordChar(prevChar) !== endType) break;
          i--;
        }

        return i;
      }

      function findWordEnd(text, pos) {
        if (pos >= text.length - 1) return text.length - 1;

        let i = pos + 1;

        // 1. Skip whitespace forward
        while (i < text.length && isWhitespace(text[i])) {
          i++;
        }

        if (i >= text.length) return text.length - 1;

        let startType = isWordChar(text[i]);

        // 2. Go to end of this word
        while (i < text.length - 1) {
          let nextChar = text[i + 1];
          if (isWhitespace(nextChar)) break;
          if (isWordChar(nextChar) !== startType) break;
          i++;
        }

        return i;
      }

      function handleNormalMode(e, textarea) {
        const key = e.key;
        const text = textarea.value;
        // Logic to determine the "active" cursor position (Head)
        // If we have a selection, we want to move from the active end
        const pos = (textarea.selectionDirection === 'backward')
          ? textarea.selectionStart
          : textarea.selectionEnd;

        const { lineStart, lineEnd, lineText } = (function () {
          const start = text.lastIndexOf('\n', pos - 1) + 1;
          const end = text.indexOf('\n', pos);
          const validEnd = end === -1 ? text.length : end;
          return {
            lineStart: start,
            lineEnd: validEnd,
            lineText: text.substring(start, validEnd)
          };
        })();

        // Check for pending command sequences
        if (state.pending) {
          if (state.pending === 'g' && key === 'g') {
            // gg - go to start
            moveCursor(textarea, 0);
          }

          state.pending = '';
          e.preventDefault();
          return;
        }



        switch (key) {
          // Mode switch

          // Helix-style Line Selection
          case 'x':
            // Select current line
            {
              const pos = (textarea.selectionDirection === 'backward') ? textarea.selectionStart : textarea.selectionEnd;
              const startI = text.lastIndexOf('\n', pos - 1) + 1;
              const endI = text.indexOf('\n', pos);
              const validEnd = endI === -1 ? text.length : endI + 1; // +1 to include \n

              // If we are already selecting this line, maybe extend? 
              // But for now just select current line.
              textarea.setSelectionRange(startI, validEnd);
              updateBlockCursor(textarea);
            }
            e.preventDefault();
            break;

          case 'i':
            state.mode = 'insert';
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'a':
            state.mode = 'insert';
            moveCursor(textarea, pos + 1);
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'A':
            // Append at end of line
            state.mode = 'insert';
            moveCursor(textarea, lineEnd);
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'I':
            // Insert at start of line
            state.mode = 'insert';
            moveCursor(textarea, lineStart);
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'o':
            state.mode = 'insert';
            const newLinePos = lineEnd;
            textarea.value = text.substring(0, lineEnd) + '\n' + text.substring(lineEnd);
            moveCursor(textarea, newLinePos + 1);
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'O':
            state.mode = 'insert';
            textarea.value = text.substring(0, lineStart) + '\n' + text.substring(lineStart);
            moveCursor(textarea, lineStart);
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            updateModeIndicator(textarea);
            e.preventDefault();
            break;

          // Navigation
          case 'h':
            moveCursor(textarea, pos - 1);
            e.preventDefault();
            break;
          case 'j':
            // Move down one line
            const colJ = pos - lineStart;
            const nextLineStart = lineEnd + 1;
            if (nextLineStart <= text.length) {
              const nextLineEnd = text.indexOf('\n', nextLineStart);
              const nextLineLen = (nextLineEnd === -1 ? text.length : nextLineEnd) - nextLineStart;
              moveCursor(textarea, nextLineStart + Math.min(colJ, nextLineLen));
            }
            e.preventDefault();
            break;
          case 'k':
            // Move up one line
            const colK = pos - lineStart;
            if (lineStart > 0) {
              const prevLineEnd = lineStart - 1;
              const prevLineStart = text.lastIndexOf('\n', prevLineEnd - 1) + 1;
              const prevLineLen = prevLineEnd - prevLineStart;
              moveCursor(textarea, prevLineStart + Math.min(colK, prevLineLen));
            }
            e.preventDefault();
            break;
          case 'l':
            moveCursor(textarea, pos + 1);
            e.preventDefault();
            break;

          // Word motion (Helix style: select to next word)
          case 'w':
            const nextPos = findNextWord(text, pos);
            // Select from current pos to nextPos
            // Using setSelectionRange(start, end, direction)
            textarea.setSelectionRange(pos, nextPos, 'forward');
            // Scroll to end of selection
            scrollToCursor(textarea, nextPos);
            updateBlockCursor(textarea);
            e.preventDefault();
            break;

          case 'b':
            const prevPos = findPrevWord(text, pos);
            // Helix style: select backwards from current pos to prevPos
            textarea.setSelectionRange(prevPos, pos, 'backward');
            scrollToCursor(textarea, prevPos);
            updateBlockCursor(textarea);
            e.preventDefault();
            break;
          case 'e':
            moveCursor(textarea, findWordEnd(text, pos));
            e.preventDefault();
            break;

          // Line start/end/doc
          case '0':
            moveCursor(textarea, lineStart);
            e.preventDefault();
            break;
          case '$':
            moveCursor(textarea, lineEnd);
            e.preventDefault();
            break;
          case 'g':
            state.pending = 'g';
            e.preventDefault();
            break;
          case 'G':
            moveCursor(textarea, text.length);
            e.preventDefault();
            break;

          // Operators
          case 'd':
            // d - delete selection (or single char if collapsed)
            {
              const start = textarea.selectionStart;
              const end = textarea.selectionEnd;
              if (start === end && pos < text.length) {
                // Collapsed: select current char
                textarea.setSelectionRange(pos, pos + 1);
              }
              // read selection
              state.register = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);
              document.execCommand('delete');

              // If we were collapsed, we are now collapsed at pos.
              // If we were a range, we are now collapsed at start of range.
              updateBlockCursor(textarea);
            }
            e.preventDefault();
            break;

          case 'y':
            // y - yank selection (or single char if collapsed)
            {
              let start = textarea.selectionStart;
              let end = textarea.selectionEnd;
              let wasCollapsed = (start === end);

              if (wasCollapsed && pos < text.length) {
                // Select char temporarily for yanking
                textarea.setSelectionRange(pos, pos + 1);
                start = pos;
                end = pos + 1;
              }

              state.register = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);

              // If it was collapsed, restore cursor to collapsed
              if (wasCollapsed) {
                textarea.setSelectionRange(pos, pos);
              }
              // If it was a range, some editors keep selection (Helix), some collapse (Vim).
              // Helix usually keeps selection. Let's keep it.
            }
            e.preventDefault();
            break;

          case 'D':
            // D - delete to end of line  
            textarea.setSelectionRange(pos, lineEnd);
            state.register = textarea.value.substring(pos, lineEnd);
            document.execCommand('delete');
            e.preventDefault();
            break;

          case 'p':
            // Paste after cursor
            if (state.register) {
              const pastePos = state.register.endsWith('\n') ? lineEnd + 1 : pos + 1;
              // Ensure we don't paste beyond length (though execCommand handles valid ranges)
              moveCursor(textarea, pastePos);
              document.execCommand('insertText', false, state.register);
              // execCommand leaves cursor AFTER text. 
              // Vim 'p' leaves cursor at end of pasted text? Or start? 
              // Typically: `p` puts text after cursor, and leaves cursor at END of pasted text in Vim? 
              // Actually Vim leaves cursor at start of pasted text usually (for `P`) or end? 
              // Let's stick to standard input behavior which is end.
              moveCursor(textarea, textarea.selectionEnd);
            }
            e.preventDefault();
            break;
          case 'P':
            // Paste before cursor
            if (state.register) {
              const insertPos = state.register.endsWith('\n') ? lineStart : pos;
              moveCursor(textarea, insertPos);
              document.execCommand('insertText', false, state.register);
              moveCursor(textarea, textarea.selectionEnd);
            }
            e.preventDefault();
            break;

          // Undo/Redo
          case 'u':
            document.execCommand('undo');
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            e.preventDefault();
            break;
          case 'U':
            document.execCommand('redo');
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            e.preventDefault();
            break;

          default:
            // Block any other single char input in normal mode (unless Ctrl/Alt/Meta is pressed)
            if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
              e.preventDefault();
            }
            break;
        }
      }

      function updateModeIndicator(textarea) {
        // Update visual indicator
        if (state.mode === 'normal') {
          // Hide native caret in normal mode
          textarea.style.caretColor = 'transparent';
          textarea.style.borderColor = '#f66';
          textarea.classList.add('vim-normal-mode');
          textarea.classList.remove('vim-insert-mode');
        } else {
          textarea.style.caretColor = '';
          textarea.style.borderColor = '';
          textarea.classList.add('vim-insert-mode');
          textarea.classList.remove('vim-normal-mode');
        }

        // Update block cursor visibility
        updateBlockCursor(textarea);

        // Dispatch custom event for mode change
        textarea.dispatchEvent(new CustomEvent('vimmodechange', {
          bubbles: true,
          detail: { mode: state.mode }
        }));
      }

      function simpleMarkdownHighlighter(text) {
        // Escape HTML
        let html = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Code blocks - handle triple backticks first
        html = html.replace(/```[\s\S]*?```/g, match => `<span class="hl-code-block">${match}</span>`);

        // Math Blocks ($$ ... $$)
        html = html.replace(/\$\$([\s\S]*?)\$\$/g, match => `<span class="hl-math">${match}</span>`);

        // Inline Math ($ ... $)
        // Simple regex: match $...$ where ... is not nothing and doesn't contain newline
        html = html.replace(/(\$\$[\s\S]*?\$\$)|(\$[^$\n]+?\$)/g, (match, block, inline) => {
          if (block) return match; // Already handled
          return `<span class="hl-math">${match}</span>`;
        });

        // Headers
        html = html.replace(/^#{1,6}\s+.*$/gm, match => `<span class="hl-header">${match}</span>`);

        // Inline code
        html = html.replace(/`[^`\n]+`/g, match => `<span class="hl-code-inline">${match}</span>`);

        // Images ![alt](url)
        // Use stricter matching to avoid capturing newlines or extra chars
        html = html.replace(/!\[([^\]\n]*?)\]\(([^)\n]*?)\)/g, match => `<span class="hl-image">${match}</span>`);

        // Links [text](url)
        // Ensure we don't match inside existing spans (simple check for <)
        // We match [...] but EXCLUDE starting with ! (already handled, though image replacement makes it safe)
        html = html.replace(/\[([^\]\n]*?)\]\(([^)\n]*?)\)/g, (match) => {
          return `<span class="hl-link">${match}</span>`;
        });

        // Reference style links definition [id]: url
        html = html.replace(/^\[.*?\]:\s+.*$/gm, match => `<span class="hl-ref">${match}</span>`);

        // Bold/Italic
        html = html.replace(/\*\*[^*]+\*\*/g, match => `<span class="hl-bold">${match}</span>`);
        html = html.replace(/\*[^*]+\*/g, match => `<span class="hl-italic">${match}</span>`);

        // Lists
        html = html.replace(/^(\s*[-*+]|\d+\.)\s/gm, match => `<span class="hl-list">${match}</span>`);

        // Quotes
        html = html.replace(/^>\s.*$/gm, match => `<span class="hl-quote">${match}</span>`);

        // Horizontal Rules
        html = html.replace(/^---$/gm, match => `<span class="hl-hr">${match}</span>`);

        // Handle trailing newline for pre element
        if (text.endsWith('\n')) {
          html += '<br>';
        }

        return html;
      }

      function attach(textarea) {
        // Force transparent background (in case of overrides)
        textarea.style.backgroundColor = 'transparent';

        // Find highlight layer
        const container = textarea.closest('.editor-container');
        let highlightLayer = null;
        if (container) {
          highlightLayer = container.querySelector('.highlight-layer code');
        }

        let lastValue = null;
        const syncHighlight = () => {
          if (highlightLayer) {
            // FORCE width sync to account for scrollbar differences
            // textarea.clientWidth excludes scrollbar, so we match that for the overlay
            if (highlightLayer.parentElement.style.width !== textarea.clientWidth + 'px') {
              highlightLayer.parentElement.style.width = textarea.clientWidth + 'px';
            }

            // Check if value actually changed to avoid expensive DOM updates
            const currentVal = textarea.value;
            if (currentVal !== lastValue) {
              highlightLayer.innerHTML = simpleMarkdownHighlighter(currentVal);
              lastValue = currentVal;
            }
          }
        };

        const syncScroll = () => {
          if (highlightLayer && highlightLayer.parentElement) {
            const parent = highlightLayer.parentElement;
            if (parent.scrollTop !== textarea.scrollTop) parent.scrollTop = textarea.scrollTop;
            if (parent.scrollLeft !== textarea.scrollLeft) parent.scrollLeft = textarea.scrollLeft;

            // Keep width synced during resize/scroll interactions
            if (parent.style.width !== textarea.clientWidth + 'px') {
              parent.style.width = textarea.clientWidth + 'px';
            }
          }
        };

        const syncPreview = () => {
          const preview = document.getElementById('memo-preview');
          if (preview) {
            // Calculate scroll percentage
            // Prevent division by zero
            const maxScrollTop = textarea.scrollHeight - textarea.clientHeight;
            if (maxScrollTop > 0) {
              const percentage = textarea.scrollTop / maxScrollTop;
              const previewMaxScrollTop = preview.scrollHeight - preview.clientHeight;
              preview.scrollTop = percentage * previewMaxScrollTop;
            }
          }
        };

        // Initial sync
        syncHighlight();

        // Polling loop for programmatic changes
        const poll = () => {
          syncHighlight();
          // Also force sync scroll (Leptos re-renders might reset scroll?)
          // syncScroll(); 
          if (document.body.contains(textarea)) {
            requestAnimationFrame(poll);
          }
        };
        requestAnimationFrame(poll);

        textarea.addEventListener('keydown', function (e) {
          // Escape always returns to normal mode
          if (e.key === 'Escape') {
            // If already in normal mode and has selection, collapse it (Helix style)
            if (state.mode === 'normal') {
              const pos = (textarea.selectionDirection === 'backward') ? textarea.selectionStart : textarea.selectionEnd;
              // Only collapse if there is actually a range
              if (textarea.selectionStart !== textarea.selectionEnd) {
                textarea.setSelectionRange(pos, pos);
                updateBlockCursor(textarea);
              }
            }

            state.mode = 'normal';
            state.pending = '';
            updateModeIndicator(textarea);
            e.preventDefault();
            return;
          }

          if (state.mode === 'normal') {
            handleNormalMode(e, textarea);
            // Ensure cursor updates after action
            requestAnimationFrame(() => {
              updateBlockCursor(textarea);
              syncHighlight();
              syncScroll();
              syncPreview();
            });
          } else {
            // In insert mode, hide block cursor
            if (cursorEl) cursorEl.style.display = 'none';
          }
        });

        // Update block cursor on click/focus/scroll
        const update = () => {
          if (state.mode === 'normal') updateBlockCursor(textarea);
          else if (cursorEl) cursorEl.style.display = 'none';
          syncScroll();
          syncPreview();
        };

        textarea.addEventListener('click', update);
        textarea.addEventListener('focus', update);
        textarea.addEventListener('scroll', update);
        textarea.addEventListener('input', () => {
          update();
          syncHighlight();
        });
        // Also update on window resize/scroll in case of layout changes
        window.addEventListener('resize', update);
        window.addEventListener('scroll', update); // Capture phase if needed?

        // Start in insert mode
        state.mode = 'insert';
        updateModeIndicator(textarea);
      }

      return { attach, state };
    })();

    // Auto-attach to memo textareas
    document.addEventListener('DOMContentLoaded', function () {
      const observer = new MutationObserver(function () {
        document.querySelectorAll('.memo-textarea').forEach(textarea => {
          if (!textarea.dataset.vimAttached) {
            window.VimMode.attach(textarea);
            textarea.dataset.vimAttached = 'true';
          }
        });
      });
      observer.observe(document.body, { childList: true, subtree: true });
    });
  </script>

  <style>
    /* Vim mode indicator badge */
    .vim-mode-indicator {
      display: inline-block;
      padding: 2px 8px;
      margin-left: 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .vim-mode-indicator.normal {
      background: #f66;
      color: white;
    }

    .vim-mode-indicator.insert {
      background: #6b6;
      color: white;
    }

    /* Vim normal mode - hide native caret */
    .memo-textarea.vim-normal-mode {
      caret-color: transparent;
    }

    /* Custom block cursor */
    .vim-block-cursor {
      position: absolute;
      background-color: rgba(255, 100, 100, 0.5);
      pointer-events: none;
      z-index: 9999;
      display: none;
    }
  </style>
</head>

<body></body>

</html>