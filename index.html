<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Tauri + Leptos App</title>
  <link data-trunk rel="css" href="styles.css" />
  <link data-trunk rel="copy-dir" href="public" />
  <link data-trunk rel="rust" data-wasm-opt="z" />

  <!-- Katex for Math Support -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <script>
    /**
     * Lightweight Vim/Helix Modal Editor
     * Supports: hjkl, w/b/e, dd/yy/p, i/a/o/O, Esc
     */
    window.VimMode = (function () {
      const state = {
        mode: 'insert', // 'normal' or 'insert'
        register: '',   // yanked text
        pending: '',    // pending command (e.g., 'd' waiting for 'd')
      };

      // Block cursor element
      let cursorEl = null;

      function createCursor() {
        if (!cursorEl) {
          cursorEl = document.createElement('div');
          cursorEl.className = 'vim-block-cursor';
          document.body.appendChild(cursorEl);
        }
      }

      function updateBlockCursor(textarea) {
        if (state.mode === 'normal' && document.activeElement === textarea) {
          createCursor();
          // Use selection end/start based on direction to track the "active" cursor end
          const pos = (textarea.selectionDirection === 'backward')
            ? textarea.selectionStart
            : textarea.selectionEnd;
          const coords = getCursorXY(textarea, pos);
          const rect = textarea.getBoundingClientRect();
          const scrollTop = textarea.scrollTop;

          // Calculate absolute position
          // coords are relative to padding-box origin (-scrollTop to get visual position)
          const visibleTop = coords.top - scrollTop;
          const visibleLeft = coords.left - textarea.scrollLeft;

          // Get exact border widths to offset the cursor correctly
          const computedStyle = getComputedStyle(textarea);
          const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
          const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;

          // Only show if inside visible content area (approx)
          if (visibleTop >= -coords.height && visibleTop <= textarea.clientHeight &&
            visibleLeft >= 0 && visibleLeft <= textarea.clientWidth) {

            cursorEl.style.display = 'block';
            // rect.top is border-box top. content starts at rect.top + borderTop
            cursorEl.style.top = (rect.top + borderTop + visibleTop + window.scrollY) + 'px';
            cursorEl.style.left = (rect.left + borderLeft + visibleLeft + window.scrollX) + 'px';
            cursorEl.style.height = coords.height + 'px';

            // Measure character width at cursor? 
            // We can assume monospaced, but better to measure.
            // Actually getCursorXY logic just gave point.
            // Let's set a default min-width but try to match content.
            // For now fixed width is safer/easier, or just a square.
            // Let's grab the char at cursor to measure width?
            // Simple: just use "ch" unit if font is mono, or measure 'M'
            cursorEl.style.width = '1ch';

            // Get character under cursor to display in inverted color?
            // That's complex (requires overlaying text).
            // Classic web VIM usually just uses semi-transparent block.
            cursorEl.textContent = textarea.value[pos] || ' ';
          } else {
            cursorEl.style.display = 'none';
          }
        } else {
          if (cursorEl) cursorEl.style.display = 'none';
        }
      }

      // Word boundaries for w/b/e
      // Only treat Alphanumeric (Latins, numbers, _) and Hanzi (Chinese chars) as distinct "word characters".
      // Punctuation (both ASCII and CJK full-width) will be treated as "non-word characters", acting as delimiters or separate words.
      const isWordChar = c => /[\w\u4e00-\u9fa5]/.test(c);
      const isWhitespace = c => /\s/.test(c);

      function getLineInfo(textarea) {
        const text = textarea.value;
        const pos = textarea.selectionStart;
        const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
        const lineEnd = text.indexOf('\n', pos);
        return {
          lineStart,
          lineEnd: lineEnd === -1 ? text.length : lineEnd,
          lineText: text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd)
        };
      }

      // Helper to calculate cursor coordinates
      function getCursorXY(textarea, selectionPoint) {
        const {
          scrollTop,
          scrollLeft,
          clientWidth,
          clientHeight
        } = textarea;

        // Create a dummy div to mirror the textarea
        const div = document.createElement('div');

        // Copy styles - copy EVERY relevant font/text property
        const copyStyle = getComputedStyle(textarea);
        for (const prop of [
          'font-family', 'font-size', 'font-weight', 'font-style', 'letter-spacing',
          'line-height', 'text-transform', 'word-spacing', 'text-indent',
          'white-space', 'word-wrap', 'word-break', 'overflow-wrap', 'tab-size',
          'padding-left', 'padding-right', 'padding-top', 'padding-bottom',
          'direction', 'text-align'
        ]) {
          div.style[prop] = copyStyle[prop].toString(); // Ensure string copy
        }

        // Also handling 'zoom' if it exists (non-standard but common source of mismatch)
        if (copyStyle['zoom']) div.style['zoom'] = copyStyle['zoom'];

        // Explicitly force line-height to be a pixel value if possible
        // But getComputedStyle usually returns px for line-height unless it's 'normal'
        // If 'normal', we might have issues. 

        // Specific styles for the mirror div
        div.style.position = 'absolute';
        div.style.top = '0px';
        div.style.left = '0px';
        div.style.visibility = 'hidden';
        div.style.overflow = 'hidden';

        // Use standard pre-wrap to match textarea default behavior
        div.style.whiteSpace = 'pre-wrap';

        // Match content box width (excluding scrollbar and borders)
        // clientWidth is padding-box width (content + padding)
        // We set div to copy padding, so we want div's *padding-box* width to match
        div.style.boxSizing = 'border-box';
        div.style.width = clientWidth + 'px';
        div.style.border = 'none';
        div.style.margin = '0';

        // Set text
        div.textContent = textarea.value.substring(0, selectionPoint);

        // Add a span to mark the cursor position
        const span = document.createElement('span');
        span.textContent = '|';
        div.appendChild(span);

        document.body.appendChild(div);

        const spanRect = span.getBoundingClientRect();
        const divRect = div.getBoundingClientRect();

        const coordinates = {
          // Relative to the content/padding-box origin (0,0) of the div
          // This includes padding offset + text flow position
          top: spanRect.top - divRect.top,
          left: spanRect.left - divRect.left,
          height: parseInt(copyStyle['line-height']) || 20
        };

        document.body.removeChild(div);
        return coordinates;
      }

      function scrollToCursor(textarea, pos) {
        // coords relative to padding-box origin
        const coords = getCursorXY(textarea, pos);
        const { scrollTop, clientHeight } = textarea;

        // Visible cursor Y = coords.top - scrollTop
        if (coords.top < scrollTop) {
          textarea.scrollTop = coords.top;
        } else if (coords.top + coords.height > scrollTop + clientHeight) {
          textarea.scrollTop = coords.top + coords.height - clientHeight + coords.height;
        }
      }

      function moveCursor(textarea, newPos) {
        const pos = Math.max(0, Math.min(newPos, textarea.value.length));
        textarea.setSelectionRange(pos, pos);
        scrollToCursor(textarea, pos);
        updateBlockCursor(textarea);
      }

      function findNextWord(text, pos) {
        if (pos >= text.length) return pos;

        let i = pos;
        let startType = isWordChar(text[i]);

        // 1. Skip current word or sequence of same-type non-word chars
        while (i < text.length) {
          let currentType = isWordChar(text[i]);
          let isSpace = isWhitespace(text[i]);

          // If we hit whitespace, stop skipping word
          if (isSpace) break;
          // If type changes (word <-> punctuation), stop
          if (currentType !== startType) break;
          i++;
        }

        // 2. Skip whitespace to find start of next
        while (i < text.length && isWhitespace(text[i])) {
          i++;
        }

        return i;
      }

      function findPrevWord(text, pos) {
        if (pos <= 0) return 0;
        let i = pos - 1;

        // 1. Skip whitespace backwards
        while (i > 0 && isWhitespace(text[i])) {
          i--;
        }

        // 2. Determine type of distinct word end
        let endType = isWordChar(text[i]);

        // 3. Go back to start of this word/punctuation block
        while (i > 0) {
          let prevChar = text[i - 1];
          if (isWhitespace(prevChar)) break;
          if (isWordChar(prevChar) !== endType) break;
          i--;
        }

        return i;
      }

      function findWordEnd(text, pos) {
        if (pos >= text.length - 1) return text.length - 1;

        let i = pos + 1;

        // 1. Skip whitespace forward
        while (i < text.length && isWhitespace(text[i])) {
          i++;
        }

        if (i >= text.length) return text.length - 1;

        let startType = isWordChar(text[i]);

        // 2. Go to end of this word
        while (i < text.length - 1) {
          let nextChar = text[i + 1];
          if (isWhitespace(nextChar)) break;
          if (isWordChar(nextChar) !== startType) break;
          i++;
        }

        return i;
      }

      function handleNormalMode(e, textarea) {
        const key = e.key;
        const text = textarea.value;
        // Logic to determine the "active" cursor position (Head)
        // If we have a selection, we want to move from the active end
        const pos = (textarea.selectionDirection === 'backward')
          ? textarea.selectionStart
          : textarea.selectionEnd;

        const { lineStart, lineEnd, lineText } = (function () {
          const start = text.lastIndexOf('\n', pos - 1) + 1;
          const end = text.indexOf('\n', pos);
          const validEnd = end === -1 ? text.length : end;
          return {
            lineStart: start,
            lineEnd: validEnd,
            lineText: text.substring(start, validEnd)
          };
        })();

        // Check for pending command sequences
        if (state.pending) {
          if (state.pending === 'g' && key === 'g') {
            // gg - go to start
            moveCursor(textarea, 0);
          }

          state.pending = '';
          e.preventDefault();
          return;
        }



        switch (key) {
          // Mode switch

          // Helix-style Line Selection
          case 'x':
            // Select current line
            {
              const pos = (textarea.selectionDirection === 'backward') ? textarea.selectionStart : textarea.selectionEnd;
              const startI = text.lastIndexOf('\n', pos - 1) + 1;
              const endI = text.indexOf('\n', pos);
              const validEnd = endI === -1 ? text.length : endI + 1; // +1 to include \n

              // If we are already selecting this line, maybe extend? 
              // But for now just select current line.
              textarea.setSelectionRange(startI, validEnd);
              updateBlockCursor(textarea);
            }
            e.preventDefault();
            break;

          case 'i':
            state.mode = 'insert';
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'a':
            state.mode = 'insert';
            moveCursor(textarea, pos + 1);
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'o':
            state.mode = 'insert';
            const newLinePos = lineEnd;
            textarea.value = text.substring(0, lineEnd) + '\n' + text.substring(lineEnd);
            moveCursor(textarea, newLinePos + 1);
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            updateModeIndicator(textarea);
            e.preventDefault();
            break;
          case 'O':
            state.mode = 'insert';
            textarea.value = text.substring(0, lineStart) + '\n' + text.substring(lineStart);
            moveCursor(textarea, lineStart);
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            updateModeIndicator(textarea);
            e.preventDefault();
            break;

          // Navigation
          case 'h':
            moveCursor(textarea, pos - 1);
            e.preventDefault();
            break;
          case 'j':
            // Move down one line
            const colJ = pos - lineStart;
            const nextLineStart = lineEnd + 1;
            if (nextLineStart <= text.length) {
              const nextLineEnd = text.indexOf('\n', nextLineStart);
              const nextLineLen = (nextLineEnd === -1 ? text.length : nextLineEnd) - nextLineStart;
              moveCursor(textarea, nextLineStart + Math.min(colJ, nextLineLen));
            }
            e.preventDefault();
            break;
          case 'k':
            // Move up one line
            const colK = pos - lineStart;
            if (lineStart > 0) {
              const prevLineEnd = lineStart - 1;
              const prevLineStart = text.lastIndexOf('\n', prevLineEnd - 1) + 1;
              const prevLineLen = prevLineEnd - prevLineStart;
              moveCursor(textarea, prevLineStart + Math.min(colK, prevLineLen));
            }
            e.preventDefault();
            break;
          case 'l':
            moveCursor(textarea, pos + 1);
            e.preventDefault();
            break;

          // Word motion (Helix style: select to next word)
          case 'w':
            const nextPos = findNextWord(text, pos);
            // Select from current pos to nextPos
            // Using setSelectionRange(start, end, direction)
            textarea.setSelectionRange(pos, nextPos, 'forward');
            // Scroll to end of selection
            scrollToCursor(textarea, nextPos);
            updateBlockCursor(textarea);
            e.preventDefault();
            break;

          case 'b':
            const prevPos = findPrevWord(text, pos);
            // Helix style: select backwards from current pos to prevPos
            textarea.setSelectionRange(prevPos, pos, 'backward');
            scrollToCursor(textarea, prevPos);
            updateBlockCursor(textarea);
            e.preventDefault();
            break;
          case 'e':
            moveCursor(textarea, findWordEnd(text, pos));
            e.preventDefault();
            break;

          // Line start/end/doc
          case '0':
            moveCursor(textarea, lineStart);
            e.preventDefault();
            break;
          case '$':
            moveCursor(textarea, lineEnd);
            e.preventDefault();
            break;
          case 'g':
            state.pending = 'g';
            e.preventDefault();
            break;
          case 'G':
            moveCursor(textarea, text.length);
            e.preventDefault();
            break;

          // Operators
          case 'd':
            // d - delete selection (or single char if collapsed)
            {
              const start = textarea.selectionStart;
              const end = textarea.selectionEnd;
              if (start === end && pos < text.length) {
                // Collapsed: select current char
                textarea.setSelectionRange(pos, pos + 1);
              }
              // read selection
              state.register = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);
              document.execCommand('delete');

              // If we were collapsed, we are now collapsed at pos.
              // If we were a range, we are now collapsed at start of range.
              updateBlockCursor(textarea);
            }
            e.preventDefault();
            break;

          case 'y':
            // y - yank selection (or single char if collapsed)
            {
              let start = textarea.selectionStart;
              let end = textarea.selectionEnd;
              let wasCollapsed = (start === end);

              if (wasCollapsed && pos < text.length) {
                // Select char temporarily for yanking
                textarea.setSelectionRange(pos, pos + 1);
                start = pos;
                end = pos + 1;
              }

              state.register = textarea.value.substring(textarea.selectionStart, textarea.selectionEnd);

              // If it was collapsed, restore cursor to collapsed
              if (wasCollapsed) {
                textarea.setSelectionRange(pos, pos);
              }
              // If it was a range, some editors keep selection (Helix), some collapse (Vim).
              // Helix usually keeps selection. Let's keep it.
            }
            e.preventDefault();
            break;

          case 'D':
            // D - delete to end of line  
            textarea.setSelectionRange(pos, lineEnd);
            state.register = textarea.value.substring(pos, lineEnd);
            document.execCommand('delete');
            e.preventDefault();
            break;

          case 'p':
            // Paste after cursor
            if (state.register) {
              const pastePos = state.register.endsWith('\n') ? lineEnd + 1 : pos + 1;
              // Ensure we don't paste beyond length (though execCommand handles valid ranges)
              moveCursor(textarea, pastePos);
              document.execCommand('insertText', false, state.register);
              // execCommand leaves cursor AFTER text. 
              // Vim 'p' leaves cursor at end of pasted text? Or start? 
              // Typically: `p` puts text after cursor, and leaves cursor at END of pasted text in Vim? 
              // Actually Vim leaves cursor at start of pasted text usually (for `P`) or end? 
              // Let's stick to standard input behavior which is end.
              moveCursor(textarea, textarea.selectionEnd);
            }
            e.preventDefault();
            break;
          case 'P':
            // Paste before cursor
            if (state.register) {
              const insertPos = state.register.endsWith('\n') ? lineStart : pos;
              moveCursor(textarea, insertPos);
              document.execCommand('insertText', false, state.register);
              moveCursor(textarea, textarea.selectionEnd);
            }
            e.preventDefault();
            break;

          // Undo/Redo
          case 'u':
            document.execCommand('undo');
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            e.preventDefault();
            break;
          case 'U':
            document.execCommand('redo');
            textarea.dispatchEvent(new Event('input', { bubbles: true }));
            e.preventDefault();
            break;

          default:
            // Block any other single char input in normal mode (unless Ctrl/Alt/Meta is pressed)
            if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
              e.preventDefault();
            }
            break;
        }
      }

      function updateModeIndicator(textarea) {
        // Update visual indicator
        if (state.mode === 'normal') {
          // Hide native caret in normal mode
          textarea.style.caretColor = 'transparent';
          textarea.style.borderColor = '#f66';
          textarea.classList.add('vim-normal-mode');
          textarea.classList.remove('vim-insert-mode');
        } else {
          textarea.style.caretColor = '';
          textarea.style.borderColor = '';
          textarea.classList.add('vim-insert-mode');
          textarea.classList.remove('vim-normal-mode');
        }

        // Update block cursor visibility
        updateBlockCursor(textarea);

        // Dispatch custom event for mode change
        textarea.dispatchEvent(new CustomEvent('vimmodechange', {
          bubbles: true,
          detail: { mode: state.mode }
        }));
      }

      function attach(textarea) {
        textarea.addEventListener('keydown', function (e) {
          // Escape always returns to normal mode
          if (e.key === 'Escape') {
            // If already in normal mode and has selection, collapse it (Helix style)
            if (state.mode === 'normal') {
              const pos = (textarea.selectionDirection === 'backward') ? textarea.selectionStart : textarea.selectionEnd;
              // Only collapse if there is actually a range
              if (textarea.selectionStart !== textarea.selectionEnd) {
                textarea.setSelectionRange(pos, pos);
                updateBlockCursor(textarea);
              }
            }

            state.mode = 'normal';
            state.pending = '';
            updateModeIndicator(textarea);
            e.preventDefault();
            return;
          }

          if (state.mode === 'normal') {
            handleNormalMode(e, textarea);
            // Ensure cursor updates after action
            requestAnimationFrame(() => updateBlockCursor(textarea));
          } else {
            // In insert mode, hide block cursor
            if (cursorEl) cursorEl.style.display = 'none';
          }
        });

        // Update block cursor on click/focus/scroll
        const update = () => {
          if (state.mode === 'normal') updateBlockCursor(textarea);
          else if (cursorEl) cursorEl.style.display = 'none';
        };

        textarea.addEventListener('click', update);
        textarea.addEventListener('focus', update);
        textarea.addEventListener('scroll', update);
        textarea.addEventListener('input', update);
        // Also update on window resize/scroll in case of layout changes
        window.addEventListener('resize', update);
        window.addEventListener('scroll', update); // Capture phase if needed?

        // Start in insert mode
        state.mode = 'insert';
        updateModeIndicator(textarea);
      }

      return { attach, state };
    })();

    // Auto-attach to memo textareas
    document.addEventListener('DOMContentLoaded', function () {
      const observer = new MutationObserver(function () {
        document.querySelectorAll('.memo-textarea').forEach(textarea => {
          if (!textarea.dataset.vimAttached) {
            window.VimMode.attach(textarea);
            textarea.dataset.vimAttached = 'true';
          }
        });
      });
      observer.observe(document.body, { childList: true, subtree: true });
    });
  </script>

  <style>
    /* Vim mode indicator badge */
    .vim-mode-indicator {
      display: inline-block;
      padding: 2px 8px;
      margin-left: 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .vim-mode-indicator.normal {
      background: #f66;
      color: white;
    }

    .vim-mode-indicator.insert {
      background: #6b6;
      color: white;
    }

    /* Vim normal mode - hide native caret */
    .memo-textarea.vim-normal-mode {
      caret-color: transparent;
    }

    /* Custom block cursor */
    .vim-block-cursor {
      position: absolute;
      background-color: rgba(255, 100, 100, 0.5);
      pointer-events: none;
      z-index: 9999;
      display: none;
    }
  </style>
</head>

<body></body>

</html>